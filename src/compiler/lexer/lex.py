import ply.lex as lex
import re
from ..cmp.grammar import G


class CoolLexer(object): 
    reserved = {
        'class': 'CLASS',
        'inherits': 'INHERITS',
        'let': 'LET',
        'in': 'IN',
        'case': 'CASE',
        'of': 'OF',
        'esac': 'ESAC',
        'while': 'WHILE',
        'loop': 'LOOP',
        'pool': 'POOL',
        'if': 'IF',
        'then': 'THEN',
        'else': 'ELSE',
        'fi': 'FI',
        'isvoid': 'ISVOID',
        'not': 'NOT',
        'new': 'NEW',
        'true': 'TRUE',
        'false': 'FALSE'
    }

    tokens = [
        'SEMICOLON',
        'COLON',
        'COMMA',
        'DOT',
        'OPAR',
        'CPAR',
        'OCUR',
        'CCUR',
        'LARROW',
        'RARROW',
        'AT',
        'EQUAL',
        'PLUS',
        'MINUS',
        'STAR',
        'DIV',
        'LESS',
        'LEQ',
        'NEG',
        'TYPEIDENTIFIER',
        'OBJECTIDENTIFIER',
        'NUMBER',
        'STRING'
    ] + list(reserved.values())

    token_type = {
        'CLASS' : G.classx,
        'INHERITS' : G.inherits,
        'LET' : G.let,
        'IN' : G.inx,
        'CASE': G.case,
        'OF': G.of,
        'ESAC': G.esac,
        'WHILE': G.whilex,
        'LOOP': G.loop,
        'POOL': G.pool,
        'IF': G.ifx,
        'THEN': G.then,
        'ELSE': G.elsex,
        'FI': G.fi,
        'ISVOID': G.isvoid,
        'NOT': G.notx,
        'NEW': G.new,
        'TRUE': G.boolx,
        'FALSE': G.boolx,
        'SEMICOLON': G.semi,
        'COLON': G.colon,
        'COMMA': G.comma,
        'DOT': G.dot,
        'OPAR': G.opar,
        'CPAR': G.cpar,
        'OCUR': G.ocur,
        'CCUR': G.ccur,
        'LARROW': G.larrow,
        'RARROW': G.rarrow,
        'AT': G.at,
        'EQUAL': G.equal,
        'PLUS': G.plus,
        'MINUS': G.minus,
        'STAR': G.star,
        'DIV': G.div,
        'LESS': G.less,
        'LEQ': G.leq,
        'NEG': G.neg,
        'TYPEIDENTIFIER': G.typeid,
        'OBJECTIDENTIFIER': G.objectid,
        'NUMBER': G.num,
        'STRING': G.stringx
    }

